// src/data/csv-resolution-manager.js - CSV-based Multi-Resolution Data Manager
// Manages zoom-level dependent data loading from CSV resolution files
// Supports: hours, minutes, seconds, 100ms, 10ms, 1ms bins, raw (microsecond packets)

/**
 * LRU Cache for storing loaded chunks
 */
class LRUCache {
    constructor(maxSize = 50) {
        this.maxSize = maxSize;
        this.cache = new Map();
    }

    get(key) {
        if (!this.cache.has(key)) return undefined;
        const value = this.cache.get(key);
        this.cache.delete(key);
        this.cache.set(key, value);
        return value;
    }

    set(key, value) {
        if (this.cache.has(key)) {
            this.cache.delete(key);
        } else if (this.cache.size >= this.maxSize) {
            const oldest = this.cache.keys().next().value;
            this.cache.delete(oldest);
        }
        this.cache.set(key, value);
    }

    has(key) {
        return this.cache.has(key);
    }

    clear() {
        this.cache.clear();
    }

    get size() {
        return this.cache.size;
    }
}

/**
 * Single configuration for all resolution levels.
 * Order matters: first match wins (check from top to bottom).
 * To add a new resolution, just add an entry here - no other code changes needed.
 *
 * Resolution thresholds aligned with overview chart's adaptive loading (flow_bins_index.json):
 * - Overview uses 1min when range <= 120 minutes
 * - Overview uses hour when range > 7200 minutes (5 days)
 *
 * Packet view thresholds:
 * - hours: used when viewing > 120 minutes (matches overview switching to coarser)
 * - minutes: used when viewing > 10 minutes (matches overview's 1min range)
 * - seconds: used when viewing > 1 minute
 * - 100ms: used when viewing > 10 seconds
 * - 10ms: used when viewing > 1 second
 * - 1ms: used when viewing > 100ms
 * - raw: used when viewing < 100ms (individual packets)
 */
const RESOLUTION_CONFIG = [
    {
        name: 'hours',
        dirName: 'hours',
        threshold: 120 * 60 * 1_000_000, // > 120 minutes visible: use hours (matches overview 1min->hour transition)
        binSize: 3_600_000_000,          // 1 hour in microseconds
        preBinned: true,
        isSingleFile: true,              // hours uses a single data.csv
        cacheSize: 0                     // no cache needed, loaded once
    },
    {
        name: 'minutes',
        dirName: 'minutes',
        threshold: 10 * 60 * 1_000_000,  // > 10 minutes visible: use minutes (matches overview 1s->1min transition)
        binSize: 60_000_000,             // 1 minute in microseconds
        preBinned: true,
        isSingleFile: true,              // minutes uses a single data.csv
        cacheSize: 0                     // no cache needed, loaded once
    },
    {
        name: 'seconds',
        dirName: 'seconds',
        threshold: 60 * 1_000_000,       // > 60s visible: use seconds
        binSize: 1_000_000,              // 1 second in microseconds
        preBinned: true,
        isSingleFile: true,              // seconds uses a single data.csv
        cacheSize: 0                     // no cache needed, loaded once
    },
    {
        name: '100ms',
        dirName: '100ms',
        threshold: 10 * 1_000_000,       // > 10s visible: use 100ms
        binSize: 100_000,                // 100ms in microseconds
        preBinned: true,
        isSingleFile: false,
        cacheSize: 30
    },
    {
        name: '10ms',
        dirName: '10ms',
        threshold: 1 * 1_000_000,        // > 1s visible: use 10ms
        binSize: 10_000,                 // 10ms in microseconds
        preBinned: true,
        isSingleFile: false,
        cacheSize: 40
    },
    {
        name: '1ms',
        dirName: '1ms',
        threshold: 100_000,              // > 100ms visible: use 1ms
        binSize: 1_000,                  // 1ms in microseconds
        preBinned: true,
        isSingleFile: false,
        cacheSize: 50
    },
    {
        name: 'raw',
        dirName: 'raw',
        threshold: 0,                    // < 100ms visible: use raw
        binSize: 1,                      // individual packets
        preBinned: false,
        isSingleFile: false,
        cacheSize: 50
    }
];

// Build lookup map for quick access by name
const RESOLUTION_BY_NAME = Object.fromEntries(
    RESOLUTION_CONFIG.map(r => [r.name, r])
);

/**
 * CSV-based Multi-Resolution Data Manager
 * Reads from resolution folder structure generated by Python script
 */
export class CSVResolutionManager {
    constructor() {
        // Folder handle for File System Access API
        this.folderHandle = null;
        this.resolutionsHandle = null;

        // Dynamic storage keyed by resolution name
        this.indices = new Map();      // resolution name -> index data
        this.caches = new Map();       // resolution name -> LRUCache
        this.singleFileData = new Map(); // resolution name -> data (for isSingleFile resolutions)

        // Initialize caches based on config
        for (const res of RESOLUTION_CONFIG) {
            if (!res.isSingleFile && res.cacheSize > 0) {
                this.caches.set(res.name, new LRUCache(res.cacheSize));
            }
        }

        // Loading state
        this.loadingChunks = new Set();

        // Current state
        this.currentResolution = RESOLUTION_CONFIG[0].name;
        this.timeExtent = null;

        // Hysteresis to prevent flickering
        this.lastSwitchTime = 0;
        this.MIN_SWITCH_INTERVAL_MS = 100;

        // Callbacks
        this.onResolutionChange = null;
        this.onLoadingStart = null;
        this.onLoadingEnd = null;
    }

    /**
     * Initialize the resolution manager with a folder handle
     * @param {FileSystemDirectoryHandle} folderHandle - Folder containing resolutions/
     * @returns {Promise<Array>} Initial data from first resolution level
     */
    async init(folderHandle) {
        this.folderHandle = folderHandle;

        console.log('[CSVResManager] Initializing...');

        try {
            // Get resolutions directory handle
            this.resolutionsHandle = await folderHandle.getDirectoryHandle('resolutions');

            // Load all index files based on config
            await this._loadIndices();

            // Load single-file resolution data (e.g., seconds)
            await this._loadSingleFileData();

            const firstRes = RESOLUTION_CONFIG[0].name;
            const initialData = this.singleFileData.get(firstRes) || [];
            console.log(`[CSVResManager] Initialized with ${initialData.length} ${firstRes} bins`);

            return initialData;
        } catch (err) {
            console.error('[CSVResManager] Initialization failed:', err);
            throw err;
        }
    }

    /**
     * Load all resolution index files based on RESOLUTION_CONFIG
     * @private
     */
    async _loadIndices() {
        for (const res of RESOLUTION_CONFIG) {
            try {
                const resDir = await this.resolutionsHandle.getDirectoryHandle(res.dirName);
                const indexFile = await resDir.getFileHandle('index.json');
                const indexData = await (await indexFile.getFile()).text();
                const index = JSON.parse(indexData);
                this.indices.set(res.name, index);

                const count = res.isSingleFile ? index.total_count : (index.chunks?.length || 0);
                console.log(`[CSVResManager] Loaded ${res.name} index: ${count} ${res.isSingleFile ? 'bins' : 'chunks'}`);

                // Set time extent from first resolution with valid time_range
                if (!this.timeExtent && index.time_range) {
                    this.timeExtent = [index.time_range.start, index.time_range.end];
                }
            } catch (err) {
                console.warn(`[CSVResManager] Failed to load ${res.name} index:`, err);
            }
        }
    }

    /**
     * Load data for single-file resolutions (e.g., seconds)
     * @private
     */
    async _loadSingleFileData() {
        for (const res of RESOLUTION_CONFIG) {
            if (!res.isSingleFile) continue;

            const index = this.indices.get(res.name);
            if (!index) continue;

            try {
                const resDir = await this.resolutionsHandle.getDirectoryHandle(res.dirName);
                const dataFile = await resDir.getFileHandle(index.data_file || 'data.csv');
                const csvText = await (await dataFile.getFile()).text();

                const data = this._parseCSV(csvText, res);
                this.singleFileData.set(res.name, data);
                console.log(`[CSVResManager] Loaded ${data.length} ${res.name} bins`);
            } catch (err) {
                console.error(`[CSVResManager] Failed to load ${res.name} data:`, err);
                this.singleFileData.set(res.name, []);
            }
        }
    }

    /**
     * Parse CSV text into array of objects
     * @param {string} csvText - CSV content
     * @param {Object} resConfig - Resolution config object from RESOLUTION_CONFIG
     * @private
     */
    _parseCSV(csvText, resConfig = null) {
        const lines = csvText.split('\n').filter(line => line.trim());
        if (lines.length < 2) return [];

        const headers = lines[0].split(',').map(h => h.trim());
        const data = [];
        const binSize = resConfig?.binSize || 1_000_000;
        const preBinned = resConfig?.preBinned !== false;
        const resName = resConfig?.name || 'unknown';

        for (let i = 1; i < lines.length; i++) {
            const values = lines[i].split(',');
            if (values.length < headers.length) continue;

            const row = {};
            for (let j = 0; j < headers.length; j++) {
                const header = headers[j];
                let value = values[j]?.trim() || '';

                // Type conversion
                if (['timestamp', 'bin_start', 'bin_end', 'count', 'total_bytes', 'src_port', 'dst_port', 'flags', 'length'].includes(header)) {
                    value = parseInt(value) || 0;
                }

                row[header] = value;
            }

            // Add binned flag and compute additional properties
            row.binned = preBinned;
            row.binStart = row.bin_start || row.timestamp;
            row.binEnd = row.bin_end || (row.timestamp + binSize);
            row.binCenter = Math.floor((row.binStart + row.binEnd) / 2);
            row.flagType = row.flag_type || 'OTHER';
            row.preBinnedSize = row.binEnd - row.binStart;
            row.resolution = resName;

            data.push(row);
        }

        return data;
    }

    /**
     * Get the required resolution for a given visible time range
     * @param {number} visibleRange - Time range in microseconds
     * @returns {string} Resolution level name
     */
    getResolutionForRange(visibleRange) {
        const now = performance.now();
        const timeSinceLastSwitch = now - this.lastSwitchTime;

        // Find first resolution where visibleRange > threshold (config is ordered by threshold desc)
        let targetResolution = RESOLUTION_CONFIG[RESOLUTION_CONFIG.length - 1].name;
        for (const res of RESOLUTION_CONFIG) {
            if (visibleRange > res.threshold) {
                targetResolution = res.name;
                break;
            }
        }

        // Apply minimum switch interval to prevent flickering
        if (targetResolution !== this.currentResolution) {
            if (timeSinceLastSwitch < this.MIN_SWITCH_INTERVAL_MS) {
                return this.currentResolution;
            }
            this.lastSwitchTime = now;
            console.log(`[CSVResManager] Resolution: ${this.currentResolution} -> ${targetResolution}`);
            this.currentResolution = targetResolution;
        }

        return targetResolution;
    }

    /**
     * Get resolution info including transition state
     * @param {number} visibleRange - Time range in microseconds
     * @returns {Object} Resolution info
     */
    getResolutionInfo(visibleRange) {
        const previousResolution = this.currentResolution;
        const resolution = this.getResolutionForRange(visibleRange);

        return {
            resolution,
            switchedResolution: resolution !== previousResolution,
            transitionProgress: 0,
            shouldPrefetch: false,
            prefetchResolution: null
        };
    }

    /**
     * Get data for the current domain with non-blocking loading
     * @param {[number, number]} domain - [startTime, endTime] in microseconds
     * @returns {Promise<Object>} { data, resolution, isLoading, loadingPromise }
     */
    async getDataForDomainNonBlocking(domain) {
        const [start, end] = domain;
        const visibleRange = end - start;

        const resInfo = this.getResolutionInfo(visibleRange);
        const requiredResolution = resInfo.resolution;
        const resConfig = RESOLUTION_BY_NAME[requiredResolution];

        console.log(`[CSVResManager] Getting data for [${start}, ${end}], range=${(visibleRange/1_000_000).toFixed(2)}s, res=${requiredResolution}`);

        // Get immediate data
        let immediateData = await this._getImmediateData(domain, requiredResolution);
        let isLoading = false;
        let loadingPromise = null;

        // Check if we need to load chunk data (not for single-file resolutions)
        if (resConfig && !resConfig.isSingleFile) {
            const missingChunks = this._getMissingChunks(domain, requiredResolution);

            if (missingChunks.length > 0) {
                isLoading = true;
                loadingPromise = this._loadChunks(missingChunks, requiredResolution, domain);
            }
        }

        if (resInfo.switchedResolution && this.onResolutionChange) {
            this.onResolutionChange(requiredResolution, resInfo);
        }

        return {
            data: immediateData,
            resolution: requiredResolution,
            isLoading,
            loadingPromise,
            transitionInfo: resInfo
        };
    }

    /**
     * Get best available data immediately without blocking
     * @private
     */
    async _getImmediateData(domain, targetResolution) {
        const [start, end] = domain;
        const resConfig = RESOLUTION_BY_NAME[targetResolution];

        // For single-file resolutions, use pre-loaded data
        if (resConfig?.isSingleFile) {
            const data = this.singleFileData.get(targetResolution);
            if (data) {
                return data.filter(d => {
                    const t = d.binStart || d.timestamp;
                    return t >= start && t <= end;
                });
            }
        }

        // For chunked resolutions, try to assemble from cache
        if (resConfig && !resConfig.isSingleFile) {
            const cache = this.caches.get(targetResolution);
            const index = this.indices.get(targetResolution);
            if (cache && index) {
                const cachedData = this._assembleFromCache(domain, cache, index);
                if (cachedData.length > 0) return cachedData;
            }
        }

        // Fall back to first available single-file resolution data
        for (const res of RESOLUTION_CONFIG) {
            if (res.isSingleFile) {
                const data = this.singleFileData.get(res.name);
                if (data && data.length > 0) {
                    return data.filter(d => {
                        const t = d.binStart || d.timestamp;
                        return t >= start && t <= end;
                    });
                }
            }
        }

        return [];
    }

    /**
     * Get chunks that need to be loaded for the domain
     * @private
     */
    _getMissingChunks(domain, resolution) {
        const [start, end] = domain;
        const index = this.indices.get(resolution);
        const cache = this.caches.get(resolution);

        if (!index || !index.chunks || !cache) return [];

        const missing = [];
        for (const chunk of index.chunks) {
            // Check if chunk overlaps with domain
            if (chunk.end < start || chunk.start > end) continue;

            // Check if chunk is already cached or loading
            if (!cache.has(chunk.file) && !this.loadingChunks.has(chunk.file)) {
                missing.push(chunk);
            }
        }

        return missing;
    }

    /**
     * Load chunks and return assembled data
     * @private
     */
    async _loadChunks(chunks, resolution, domain) {
        if (chunks.length === 0) return [];

        if (this.onLoadingStart) this.onLoadingStart();

        const resConfig = RESOLUTION_BY_NAME[resolution];
        const index = this.indices.get(resolution);
        const cache = this.caches.get(resolution);

        if (!resConfig || !cache) {
            console.warn(`[CSVResManager] Unknown resolution: ${resolution}`);
            if (this.onLoadingEnd) this.onLoadingEnd();
            return [];
        }

        try {
            const resDir = await this.resolutionsHandle.getDirectoryHandle(resConfig.dirName);

            // Load chunks in parallel
            await Promise.all(chunks.map(async (chunk) => {
                if (this.loadingChunks.has(chunk.file)) return;
                this.loadingChunks.add(chunk.file);

                try {
                    const file = await resDir.getFileHandle(chunk.file);
                    const csvText = await (await file.getFile()).text();
                    const data = this._parseCSV(csvText, resConfig);
                    cache.set(chunk.file, data);
                    console.log(`[CSVResManager] Loaded ${chunk.file}: ${data.length} items`);
                } catch (err) {
                    console.error(`[CSVResManager] Failed to load ${chunk.file}:`, err);
                } finally {
                    this.loadingChunks.delete(chunk.file);
                }
            }));

            // Assemble and return data
            return this._assembleFromCache(domain, cache, index);

        } finally {
            if (this.onLoadingEnd) this.onLoadingEnd();
        }
    }

    /**
     * Assemble data from cache for a domain
     * @private
     */
    _assembleFromCache(domain, cache, index) {
        if (!index || !index.chunks) return [];

        const [start, end] = domain;
        const allData = [];

        for (const chunk of index.chunks) {
            // Check if chunk overlaps with domain
            if (chunk.end < start || chunk.start > end) continue;

            const chunkData = cache.get(chunk.file);
            if (chunkData) {
                // Filter to exact domain
                const filtered = chunkData.filter(d => {
                    const t = d.binStart || d.timestamp;
                    return t >= start && t <= end;
                });
                allData.push(...filtered);
            }
        }

        // Sort by timestamp
        allData.sort((a, b) => (a.timestamp || a.binStart) - (b.timestamp || b.binStart));

        return allData;
    }

    /**
     * Get memory stats
     */
    getMemoryStats() {
        const stats = { loadingChunks: this.loadingChunks.size };

        for (const res of RESOLUTION_CONFIG) {
            if (res.isSingleFile) {
                const data = this.singleFileData.get(res.name);
                stats[`${res.name}Count`] = data?.length || 0;
            } else {
                const cache = this.caches.get(res.name);
                stats[`${res.name}CacheChunks`] = cache?.size || 0;
            }
        }

        return stats;
    }

    /**
     * Clear all cached data
     */
    clear() {
        this.singleFileData.clear();
        for (const cache of this.caches.values()) {
            cache.clear();
        }
        this.loadingChunks.clear();
        this.currentResolution = RESOLUTION_CONFIG[0].name;
    }
}

// Export config and singleton instance
export { RESOLUTION_CONFIG, RESOLUTION_BY_NAME };
export const csvResolutionManager = new CSVResolutionManager();
